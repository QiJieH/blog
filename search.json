[{"title":"JavaScript 提升（Hoisting）","date":"2021-04-28T13:55:00.000Z","url":"/blog/2021/04/28/hoisting/","tags":["javascript","hositing"],"categories":["FontEnd"],"content":"JavaScript 的语法来源于C。在所有其他类似C语言风格的语言里，一个代码块（包括一对花括号中的一组语句）会创造一个作用域。代码中声明的变量在其外部是不可见的。JavaScript 采用了这样的语法，却没有提供块级作用域：代码块中声明的变量在包含此代码块的函数的任何位置都是可见的。这让其他语言编程的程序员们大为意外。 在大多数语言中，一班来说，变量声明最好的地方是在第一次用到它的地方。但这种做法在JavaScript里反而是一个坏习惯，因为它没有块级作用域。更好的方式是在每个函数的开头部分声明所有变量。 《JavaScript 语言精粹》（修订版）Douglas Crockford著 电子工业出版社 JavaScript 声明会被提升提升（Hoisting）是 JavaScript 将声明移至顶部的默认行为。ECMAScript 并没有给出提升这一概念，而是人们对JavaScript执行上下文工作方式抽象出来的一种性质。 实际的实现方式是 JavaScript 的变量和函数的声明会在编译阶段放入内存这意味着使用者在正式声明一个函数或者变量之前就能够使用它。 为了理解这一点，您必须理解术语 “hoisting”。Hoisting 是 JavaScript 将所有声明提升到当前作用域顶部的默认行为（提升到当前脚本或当前函数的顶部）。 let 和 const 关键字用 let 或 const 声明的变量和常量不会被提升！ JavaScript 初始化不会被提升JavaScript 只提升声明，而非初始化。 在顶部声明您的变量！Hoisting（对很多开发者来说）是 JavaScript 的一种未知的或被忽视的行为。如果开发者不理解 hoisting，程序也许会包含 bug（错误）。为了避免 bug，请始终在每个作用域的开头声明所有变量。由于这就是 JavaScript 解释代码的方式，请保持这个好习惯。严格模式中的 JavaScript 不允许在未被声明的情况下使用变量。 参考 w3school:js_hoisting 为什么会存在提升关于为什么存在变量提升和函数提升 JavaScript 开发者 Brendan Eich 在与 Dmitry Soshnikov 的 twitter 话题交流中曾有提到过，关于变量提升是由于第一代JS虚拟机中的抽象纰漏导致的，编译器将变量放到了栈槽内并编入索引，然后在（当前作用域的）入口处将变量名绑定到了栈槽内的变量。（注：这里提到的抽象是计算机术语，是对内部发生的更加复杂的事情的一种简化。），而函数提升，Brendan Eich 很确定的说，就是为了解决相互递归的问题，大体上可以解决像ML语言这样自下而上的顺序问题。 如果没有函数提升，而是按照自下而上的顺序，当isEven函数被调用时，isOdd函数还未声明，所以isEven内部无法调用isOdd函数，形成了死循环。所以 Brendan Eich 设计了函数提升这一形式，将函数提升至当前作用域的顶部。 最后 Brendan Eich 总结到：变量提升是人为实现的问题，而函数提升在当初设计时是有目的的。 参考 liuhe688 博文 《JavaScript: 变量提升和函数提升》 "},{"title":"浅析 JavaScript 中的 == 和 !=","date":"2021-04-27T15:44:00.000Z","url":"/blog/2021/04/27/double-equal/","tags":["javascript"],"categories":["FontEnd"],"content":"JavaScript 有两组相等运算符：=== 和 !==，以及它们邪恶的孪生兄弟 == 和 !=。=== 和 !== 这一组运算符会按照你期望的方式工作。如果两个运算类型一致且拥有相同的值，那么 === 返回 true ，!== 返回 false 。而它们邪恶的孪生兄弟只有在两个运算符类型一致时才会做出正确的判断，如果两个运算数是不同类型，它们试图去强制转换值的类型。转换的规则复杂且难以记忆。这里有一些有趣的例子： == 运算符对传递性的缺乏值得我们警惕。我的建议是永远不要使用那对邪恶的孪生兄弟。相反，请始终使用 === 和 !== 。如果以上所有的比较使用 === 运算符，结果都是 false。 传递性是一种编程约定。可以这么理解：对于任意的引用值x, y和z，如果 x==y和y==z为true，那么x==z为true。而 JavaScript 中的 == 运算符在某些特例是违背了传递性。 《JavaScript 语言精粹》（修订版）Douglas Crockford著 电子工业出版社 "},{"title":"深入浅出 JSON","date":"2021-04-26T14:30:00.000Z","url":"/blog/2021/04/26/json/","tags":["javascript","json"],"categories":["FontEnd","BackEnd"],"content":"JavaScript 对象表示法（JavaScript Object Notation, 简称 JSON ）是一种轻量级的数据交换格式。它基于 JavaScript 的对象字面量表示法，那是 JavaScript 最精华的部分之一。尽管只是 JavaScript 的一个子集，但它与语言无关。所有以现代编程语言编写的程序，都可以用它来彼此交换数据。它是一种文本格式，所以可以被人和机器阅读。它易于实现且易于使用。大量关于 JSON 的资料都可以在  中找到。 JSON 语法JSON 有 6 种类型的值：对象，数组，字符串，数字，布尔值和特殊值 null。空白（空格符，制表符，回车符和换行符）可被插到任何值的前后。这使得 JSON 文本能更容易被人阅读。为了减少传输和存储的成本，空白可以省略。 JSON 对象是一个容纳 “名/值” 对的无序集合。名字可以是任何字符串。值可以是任何类型的 JSON 值，包括数组和对象。JSON 对象可以被无限层地嵌套，但一般来说保持其结构的相对扁平是最高效的。大多数语言都有容易映射为 JSON 对象的数据类型，比如对象（object),结构（struct)，字典（dictionary），哈希表（hash table），属性列表（property list）或关联数组（associative array）。 JSON 数组是一个值的有序序列。其值可以是任何类型的 JSON 值，包括数组和对象。大多数语言都有容易被映射为 JSON 数组的数据类型，比如数组（array），向量（vector），列表（list）或序列（sequence）。 JSON 字符串被包围在一对双引号之间。\\字符被用于转义。JSON 允许/字符被转义，所以 JSON 可以嵌入 HTML 的&lt;script&gt;标签之中。 JSON 数字与 JavaScript 的数字相似。整数的首位不允许为 0 ，因为一些语言用它来表示八进制数。这种基数混乱在数据交换格式中是不可取的。数字可以是整数，实数或科学计数。 就是这样。这就是 JSON 的全部。JSON 的设计目标是成为一个极简的，轻便的和文本式的 JavaScript 子集。实现互通所需要的共识越少，互通就越容易实现。 安全地使用 JSONJSON 特别易于用在 Web 应用中，因为 JSON 就是 JavaScript。使用 eval 函数可以把一段 JSON 文本转化成一个有用的数据结构： (用圆括号把 JSON 文本括起来是一种避免 JavaScript 语法歧义的变通方案) 然而，eval 函数有着骇人的安全问题。用eval 去解析 JSON 文本安全吗？… 通过使用 JSON.parse 方法代替 eval 就能避免这种危险。如果文本中包含任何危险数据，那么 JSON.parse 将抛出一个异常… 在外部数据与 innerHTML 进行交互时还存在一个危险… 一个 JSON 解析器这是一个用 JavaScript 编写 JSON 解析器的实现方案： 《JavaScript 语言精粹》（修订版）Douglas Crockford著 电子工业出版社 "},{"title":"算法优化之记忆","date":"2021-04-24T16:19:00.000Z","url":"/blog/2021/04/25/memoization/","tags":["algorithm","optimization","memoization"],"categories":["Others"],"content":" 在计算机领域，记忆（memoization）是主要用于加速程序计算的一种优化技术，它使得函数避免重复演算之前已被处理的输入，而返回已缓存的结果。 记忆 Memoization函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。这种优化被称为记忆（memoization）。JavaScript 的对象和数组要实现这种优化是非常方便的。 比如说，我们想要一个递归函数来计算 Fibonacci 数列。一个 Fibonacci 数字是之前两个 Fibonacci 数字之和。最前面的两个数字是 0 和 1。 这样是可以工作的，但它做了很多无谓的工作。fib 函数被调用了 453 次。我们调用了 11 次，而它自身调用了 442 次去计算可能已被刚计算过的值。如果我们让该函数具备记忆功能，就可以显著地减少运算量。 我们在一个名为 memo 的数组里保存我们的存储结果，存储结果可以隐藏在闭包中。当函数被调用时，这个函数首先检查结果是否已存在，如果已经存在，就立即返回这个结果。 这个函数返回同样的结果，但它只被调用了 29 次。我们调用了它 11 次，它调用了自己 181 次去取得之前存储的结果。 我们可以吧这种技术推而广之，编写一个函数帮助我们构造带记忆功能的函数。 memoizer 函数取得一个初始的 memo 数组和 formula 函数。它返回一个管理 memo 存储和在需要时调用 formula 函数的 recur 函数。我们把这个 recur 函数和它的参数传递给 formula 函数： 现在，我们可以使用 memoizer 函数来定义 fibonacci 函数，提供其初始的 memo 数组和 formula 函数： 通过设计这种产生另一个函数的函数，极大地减少了我们的工作量。例如，要产生一个可记忆的阶乘函数，我们只需要通过基本的阶乘公式即可： 《JavaScript 语言精粹》（修订版）Douglas Crockford著 电子工业出版社 "}]