[{"title":"使用 ODT选择性安装 office","date":"2021-05-31T11:12:00.000Z","url":"/blog/2021/05/31/office-deployment-tool/","tags":["office","tool"],"categories":["Other"],"content":"借助 Office 部署工具 (ODT)，可以将 Microsoft 365 应用版下载并部署到你的客户端计算机。使用 ODT，可以更好地控制 Office 安装。也就是说，可以定义要安装的产品和语言、更新这些产品的方式，以及是否向用户显示安装体验。 以上介绍摘自官方文档，简单来说就是通过这个工具允许用户自定义安装的 office 套件及其行为，让你可以脱离使用官方安装程序带来的office全家桶，仅选择你需要的组件即可。 下载ODT从ODT下载页面下载ODT工具。 下载文件后，运行自解压缩可执行文件，其中包含 Office 部署工具可执行文件 (setup.exe) 和一个示例配置文件 (configuration.xml)。 编辑配置文件你可以参考官方文档说明自行编辑你的配置文件。 下面是一个简单示例，仅安装Word, Excel, 和PPT。你也可以通过这个配置文件排除已安装的Access, OneDrive等： 不建议自行手动配置这些代码，因为这样极大可能会导致种种错误（吃了教训），更推荐使用office 自定义工具这个网页来可视整个过程，在产品与版本的应用项目中你可以选择需要排除的应用（关闭为排除），选择完你的配置后，点击导出Office Open XML 格式进行下载 运行ODT在之前解压得到的可执行文件目录下打开命令行（管理员身份），运行以下命令后便会根据配置文件进行下载安装。 如果未安装目标版本office: 已安装但想通过配置文件删除和更新： 等待运行完成，这样你便可以拥有一个你想要的 office。 参考文档：巧用官方 ODT 清爽安装 Office | 一日一技Office 部署工具概述Office 部署工具的配置选项 "},{"title":"《JavaScript DOM 编程艺术》 读后心得","date":"2021-05-30T10:39:00.000Z","url":"/blog/2021/05/30/dom-scripting-art/","tags":["javascript","dom","html5","ajax","book"],"categories":["FontEnd"],"content":"JavaScript是Web开发中最重要的一门语言，它强大而优美。无论是桌面开发，还是移动应用。JavaScript都是必须掌握的技术。W3C的DOM标准是开发Web应用的基石。已经得到所有现代浏览器的支持，这使得跨平台Web开发成了一件轻松惬意的事。 本书是超级畅销书的升级版，由倡导Web标准的领军人物执笔，揭示了前端开发的真谛，是学习JavaScript和DOM开发的必读之作。 本书在简洁明快地讲述JavaScript和DOM的基本知识之后，通过几个实例演示了专业水准的网页开发技术，透彻阐述了平稳退化等一批至关重要的 JavaScript编程原则和最佳实践，并全面探讨了HTML5以及jQuery等JavaScript库。读者将看到JavaScript、 HTML5和CSS如何协作来创建易用的、与标准兼容的Web设计，掌握使用JavaScript和DOM通过客户端动态效果和用户控制的动画来加强 Web页面的必备技术。同时，还将对如何利用库提高开发效率有全面深入的理解。 摘自豆瓣读书内容简介 个人评价严格上来讲本书作为并非JavaScript这门语言的入门书籍，把它定位为JavaScript操作DOM教程可能更合适，它更适合那些希望通过js操作网页内容的人去阅读。本书标题概况的相当准确 :) 不得不提的是，尽管本书的某些方面的描述与编码已经过时不在适用，或者是有了更好的解决方案，但是依旧不妨碍学习本书，你大可使用更好选择解决这些问题。 不论如何，本书做为JS操作DOM的参考和学习书籍是可以肯定的，通过它你能够很迅速掌握和温习JS对DOM的操作和编程思路。除此之外，本书的某些编程原则和设计思维也是相当值得学习和借鉴的，我会尽可能的将其提炼在下方，以便后期参考和警醒。 精华提炼本书是十分优秀的编程书籍，它的每个章节都是可学习和有用的，本人技术和能力有限仅能记录下一些自认为读有所获的地方。 以下内容都是摘自本书，或结合本人个人见解融汇之后记录下的。没人能确保这些内容都是正确唯一的，你应该有自己的见解和看法。 结构与行为分离谈到 Web设计，最准确的理解是把网页看成三个层： 结构层 样式层（表现层） 行为层 这三个层分别对应不同的技术，分别是 超文本标记语言（HTML） 层叠样式表（CSS） JavaScript，文档对象模型（DOM）和浏览器对象模型（BOM） 作者认为结构与行为分离程度越大越好，把事件处理函数分离到外部的 JavaScript文件，使 js代码不再依赖于 HTML文档的内容和结构。编写代码时可以问问自己：“它的js与html标记是分离的吗？”。 理想情况下，应该在外部文件完成添加 onclick事件处理函数的工作，那样才能让标记文档没有“杂质“，就像下面这样： 最典型的违背结构与行为分离原则的示例是 document.write方法： 像上面这样把 JavaScript和 HTML代码混杂在一起是一种很不好的做法。这样的标记即不容易阅读和编辑，也无法享受行为与结构分离开来的好处。 内容为主所有的网页开发人员都知道一句话：“内容就是一切”。如果没有内容，创建网站还有何用？ 话虽如此，我们也不能一股脑的将原始内容不加描述的发布到网站上，在创网站时给内容加上正确的 HTML标签是第一步，或许也是最重要的步骤。我们可以修正那句格言为：“标记良好的内容就是一切”。请正确使用标记语言对内容做出正确描述。 如果你察觉到自己正在使用DOM技术把一些重要的内容添加到网站上，则应该立刻停下来去检讨你的计划和思路。你很可能发现自己正在滥用DOM！ 渐进增强与平稳退化这部分内容可以说是本书的重点和精华了，我会尽可能的描述和举例自己的理解和认知。在本书中这两个名词始终贯穿着作者的编码和设计理念，通读体会后受益匪浅。 渐进增强（progressive enhancement）。渐进增强原则基于这样一种思想：你应该总是从最核心的部分，也就是从内容开始。应该根据内容使用标记良好的结构；让后再逐步加强这些内容。这些增强工作即可以是通过 CSS改进呈现效果，也可以是通过 DOM添加各种行为。如果你正在使用 DOM添加核心内容，那么你添加的时机未免太迟了，内容应该在开始编写文档时就成为文档的组成部分。 平稳退化（graceful degradation）。渐进增强的实现必然支持平稳退化。如果你按照渐进增强的原则去充实内容，你为内容添加的样式和行为就自然支持平稳退化，那些缺乏必要的 CSS和 DOM支持的访问者仍可以访问你的核心内容。如果你用 JavaScript去添加这些重要内容，它就没办法支持平稳退化，不支持 JavaScript，就看不到内容。 现在我们有如下场景：用户点击链接，会在预留位置显示当前链接指向的图片，注意没有发生页面跳转。 你可以很容易编写一些像这样的代码去实现这一功能： 第一个问题是：“如果 JavaScript功能被禁用，会怎样？” 如果我把链接写成上面这样，它们在不支持或禁用了 JavaScript功能的浏览器里将毫无用处，也就是说这些代码都无法退化。 上面这段代码为此预留了后路：即使 JavaScript功能已被禁用，用户也可以浏览图片库里的所有图片，网页里的链接也可以正常工作。在没有 JavaScript的“干扰”下，浏览器将沿着 href属性给出的链接前进，用户将打开一个新窗口显示图片，而不是毫无响应。虽说用户体验不如正常情况，但网页的基本功能未受到损害——页面上的所有内容都可以访问。 把 href属性设置为一个真实存在的值不过是举手之劳，但图片库却因此能够平稳退化。 另一个更清晰的示例可以体现在一些 js函数上，你也可以使你的函数平稳退化，向后兼容： 虽然只是几条简单的 if语句，但它可以确保那些“古老”的浏览器不会因为我的脚本代码而出问题。这么做是为了让脚本有良好的向后兼容性。因为我在给网页添加各有关行为时始终遵循了“渐进增强”的原则，所以可以确切的知道我添加的那些功能都能平稳退化，我的网页在那些“古老的”浏览器也能正常浏览。那些只支持一部分 JavaScript功能但不支持 DOM的浏览器仍可以访问我的网页内容。 语句摘录 如果在编写某些代码时你就觉得它们不易理解，等日后再去阅读它们的时候就会更加困难。 如果想要改变某个元素的呈现效果，使用 CSS；如果想改变某个元素的行为，使用 DOM；如果你想根据某个元素的行为去改变它的呈现效果，请运用你的智慧，在这个问题上没有放之四海而皆准的答案。 函数记录在阅读本书时，发现了一些实用的方法函数。 window.onload事件栈 windows.onload只能绑定一个函数，但实际需求往往需要执行大量函数，通过函数嵌套并加一层封装来处理这种情况。 insertAfter 向元素之后插入 原生DOM中有insertBefore方法插入节点但是却没有对应的insertAfter，幸运的是我们可以使用现有的API自己实现。 getHTTPObject 退化XHR对象 "},{"title":"JSMin 初步使用","date":"2021-05-27T09:25:00.000Z","url":"/blog/2021/05/27/jsmin-guide/","tags":["javascript","jsmin"],"categories":["FontEnd"],"content":"JSMin 是一个压缩工具，可以从JavaScript 文件中删除注释和不必要的空白。它通常会将文件大小减少一半，从而加快下载速度。 它还鼓励更具表现力的编程风格，因为它消除了js和其文档的下载成本。 JSMin： Github:  如何使用通过上面提供的链接下载可执行文件jsmin.exe或jsmin.c（要求c运行环境）,键入命令行指令 参数说明： jsmin: 可执行文件位置。 source.js: 待压缩文件。 outfile.js: 输出文件，不指定路径会输出在当前命令行路径下。 在压缩js文件之前，最好确保你的文件符合JSLint 语法要求。"},{"title":"JavaScript 提升（Hoisting）","date":"2021-04-28T13:55:00.000Z","url":"/blog/2021/04/28/hoisting/","tags":["javascript","hositing"],"categories":["FontEnd"],"content":"JavaScript 的语法来源于C。在所有其他类似C语言风格的语言里，一个代码块（包括一对花括号中的一组语句）会创造一个作用域。代码中声明的变量在其外部是不可见的。JavaScript 采用了这样的语法，却没有提供块级作用域：代码块中声明的变量在包含此代码块的函数的任何位置都是可见的。这让其他语言编程的程序员们大为意外。 在大多数语言中，一般来说，变量声明最好的地方是在第一次用到它的地方。但这种做法在JavaScript里反而是一个坏习惯，因为它没有块级作用域。更好的方式是在每个函数的开头部分声明所有变量。 《JavaScript 语言精粹》（修订版）Douglas Crockford著 电子工业出版社 JavaScript 声明会被提升提升（Hoisting）是 JavaScript 将声明移至顶部的默认行为。ECMAScript 并没有给出提升这一概念，而是人们对JavaScript执行上下文工作方式抽象出来的一种性质。 实际的实现方式是 JavaScript 的变量和函数的声明会在编译阶段放入内存这意味着使用者在正式声明一个函数或者变量之前就能够使用它。 为了理解这一点，您必须理解术语 “hoisting”。Hoisting 是 JavaScript 将所有声明提升到当前作用域顶部的默认行为（提升到当前脚本或当前函数的顶部）。 let 和 const 关键字用 let 或 const 声明的变量和常量不会被提升！ JavaScript 初始化不会被提升JavaScript 只提升声明，而非初始化。 在顶部声明您的变量！Hoisting（对很多开发者来说）是 JavaScript 的一种未知的或被忽视的行为。如果开发者不理解 hoisting，程序也许会包含 bug（错误）。为了避免 bug，请始终在每个作用域的开头声明所有变量。由于这就是 JavaScript 解释代码的方式，请保持这个好习惯。严格模式中的 JavaScript 不允许在未被声明的情况下使用变量。 参考 w3school:js_hoisting 为什么会存在提升关于为什么存在变量提升和函数提升 JavaScript 开发者 Brendan Eich 在与 Dmitry Soshnikov 的 twitter 话题交流中曾有提到过，关于变量提升是由于第一代JS虚拟机中的抽象纰漏导致的，编译器将变量放到了栈槽内并编入索引，然后在（当前作用域的）入口处将变量名绑定到了栈槽内的变量。（注：这里提到的抽象是计算机术语，是对内部发生的更加复杂的事情的一种简化。），Brendan Eich 很确定的说，函数提升是为了解决相互递归的问题，大体上可以解决像ML语言这样自下而上的顺序问题。 如果没有函数提升，而是按照自下而上的顺序，当isEven函数被调用时，isOdd函数还未声明，所以isEven内部无法调用isOdd函数，形成了死循环。所以 Brendan Eich 设计了函数提升这一形式，将函数提升至当前作用域的顶部。 最后 Brendan Eich 总结到：变量提升是人为实现的问题，而函数提升在当初设计时是有目的的。 参考 liuhe688 博文 《JavaScript: 变量提升和函数提升》 "},{"title":"浅析 JavaScript 中的 == 和 !=","date":"2021-04-27T15:44:00.000Z","url":"/blog/2021/04/27/double-equal/","tags":["javascript"],"categories":["FontEnd"],"content":"JavaScript 有两组相等运算符：=== 和 !==，以及它们邪恶的孪生兄弟 == 和 !=。=== 和 !== 这一组运算符会按照你期望的方式工作。如果两个运算类型一致且拥有相同的值，那么 === 返回 true ，!== 返回 false 。而它们邪恶的孪生兄弟只有在两个运算符类型一致时才会做出正确的判断，如果两个运算数是不同类型，它们试图去强制转换值的类型。转换的规则复杂且难以记忆。这里有一些有趣的例子： == 运算符对传递性的缺乏值得我们警惕。我的建议是永远不要使用那对邪恶的孪生兄弟。相反，请始终使用 === 和 !== 。如果以上所有的比较使用 === 运算符，结果都是 false。 传递性是一种编程约定。可以这么理解：对于任意的引用值x, y和z，如果 x==y和y==z为true，那么x==z为true。而 JavaScript 中的 == 运算符在某些特例是违背了传递性。 《JavaScript 语言精粹》（修订版）Douglas Crockford著 电子工业出版社 "},{"title":"深入浅出 JSON","date":"2021-04-26T14:30:00.000Z","url":"/blog/2021/04/26/json/","tags":["javascript","json"],"categories":["FontEnd","BackEnd"],"content":"JavaScript 对象表示法（JavaScript Object Notation, 简称 JSON ）是一种轻量级的数据交换格式。它基于 JavaScript 的对象字面量表示法，那是 JavaScript 最精华的部分之一。尽管只是 JavaScript 的一个子集，但它与语言无关。所有以现代编程语言编写的程序，都可以用它来彼此交换数据。它是一种文本格式，所以可以被人和机器阅读。它易于实现且易于使用。大量关于 JSON 的资料都可以在  中找到。 JSON 语法JSON 有 6 种类型的值：对象，数组，字符串，数字，布尔值和特殊值 null。空白（空格符，制表符，回车符和换行符）可被插到任何值的前后。这使得 JSON 文本能更容易被人阅读。为了减少传输和存储的成本，空白可以省略。 JSON 对象是一个容纳 “名/值” 对的无序集合。名字可以是任何字符串。值可以是任何类型的 JSON 值，包括数组和对象。JSON 对象可以被无限层地嵌套，但一般来说保持其结构的相对扁平是最高效的。大多数语言都有容易映射为 JSON 对象的数据类型，比如对象（object),结构（struct)，字典（dictionary），哈希表（hash table），属性列表（property list）或关联数组（associative array）。 JSON 数组是一个值的有序序列。其值可以是任何类型的 JSON 值，包括数组和对象。大多数语言都有容易被映射为 JSON 数组的数据类型，比如数组（array），向量（vector），列表（list）或序列（sequence）。 JSON 字符串被包围在一对双引号之间。\\字符被用于转义。JSON 允许/字符被转义，所以 JSON 可以嵌入 HTML 的&lt;script&gt;标签之中。 JSON 数字与 JavaScript 的数字相似。整数的首位不允许为 0 ，因为一些语言用它来表示八进制数。这种基数混乱在数据交换格式中是不可取的。数字可以是整数，实数或科学计数。 就是这样。这就是 JSON 的全部。JSON 的设计目标是成为一个极简的，轻便的和文本式的 JavaScript 子集。实现互通所需要的共识越少，互通就越容易实现。 安全地使用 JSONJSON 特别易于用在 Web 应用中，因为 JSON 就是 JavaScript。使用 eval 函数可以把一段 JSON 文本转化成一个有用的数据结构： (用圆括号把 JSON 文本括起来是一种避免 JavaScript 语法歧义的变通方案) 然而，eval 函数有着骇人的安全问题。用eval 去解析 JSON 文本安全吗？… 通过使用 JSON.parse 方法代替 eval 就能避免这种危险。如果文本中包含任何危险数据，那么 JSON.parse 将抛出一个异常… 在外部数据与 innerHTML 进行交互时还存在一个危险… 一个 JSON 解析器这是一个用 JavaScript 编写 JSON 解析器的实现方案： 《JavaScript 语言精粹》（修订版）Douglas Crockford著 电子工业出版社 "},{"title":"算法优化之记忆","date":"2021-04-24T16:19:00.000Z","url":"/blog/2021/04/25/memoization/","tags":["algorithm","optimization","memoization"],"categories":["Others"],"content":" 在计算机领域，记忆（memoization）是主要用于加速程序计算的一种优化技术，它使得函数避免重复演算之前已被处理的输入，而返回已缓存的结果。 记忆 Memoization函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。这种优化被称为记忆（memoization）。JavaScript 的对象和数组要实现这种优化是非常方便的。 比如说，我们想要一个递归函数来计算 Fibonacci 数列。一个 Fibonacci 数字是之前两个 Fibonacci 数字之和。最前面的两个数字是 0 和 1。 这样是可以工作的，但它做了很多无谓的工作。fib 函数被调用了 453 次。我们调用了 11 次，而它自身调用了 442 次去计算可能已被刚计算过的值。如果我们让该函数具备记忆功能，就可以显著地减少运算量。 我们在一个名为 memo 的数组里保存我们的存储结果，存储结果可以隐藏在闭包中。当函数被调用时，这个函数首先检查结果是否已存在，如果已经存在，就立即返回这个结果。 这个函数返回同样的结果，但它只被调用了 29 次。我们调用了它 11 次，它调用了自己 181 次去取得之前存储的结果。 我们可以吧这种技术推而广之，编写一个函数帮助我们构造带记忆功能的函数。 memoizer 函数取得一个初始的 memo 数组和 formula 函数。它返回一个管理 memo 存储和在需要时调用 formula 函数的 recur 函数。我们把这个 recur 函数和它的参数传递给 formula 函数： 现在，我们可以使用 memoizer 函数来定义 fibonacci 函数，提供其初始的 memo 数组和 formula 函数： 通过设计这种产生另一个函数的函数，极大地减少了我们的工作量。例如，要产生一个可记忆的阶乘函数，我们只需要通过基本的阶乘公式即可： 《JavaScript 语言精粹》（修订版）Douglas Crockford著 电子工业出版社 "}]