[{"title":"浅析 JavaScript 中的 == 和 !=","date":"2021-04-27T15:44:00.000Z","url":"/blog/2021/04/27/double-equal/","tags":["javascript"],"categories":["FontEnd"],"content":"JavaScript 有两组相等运算符：=== 和 !==，以及它们邪恶的孪生兄弟 == 和 !=。=== 和 !== 这一组运算符会按照你期望的方式工作。如果两个运算类型一致且拥有相同的值，那么 === 返回 true ，!== 返回 false 。而它们邪恶的孪生兄弟只有在两个运算符类型一致时才会做出正确的判断，如果两个运算数是不同类型，它们试图去强制转换值的类型。转换的规则复杂且难以记忆。这里有一些有趣的例子： == 运算符对传递性的缺乏值得我们警惕。我的建议是永远不要使用那对邪恶的孪生兄弟。相反，请始终使用 === 和 !== 。如果以上所有的比较使用 === 运算符，结果都是 false。 传递性是一种编程约定。可以这么理解：对于任意的引用值x, y和z，如果 x==y和y==z为true，那么x==z为true。而 JavaScript 中的 == 运算符在某些特例是违背了传递性。 《JavaScript 语言精粹》（修订版）Douglas Crockford著 电子工业出版社 "},{"title":"深入浅出 JSON","date":"2021-04-26T14:30:00.000Z","url":"/blog/2021/04/26/json/","tags":["javascript","json"],"categories":["FontEnd","BackEnd"],"content":"JavaScript 对象表示法（JavaScript Object Notation, 简称 JSON ）是一种轻量级的数据交换格式。它基于 JavaScript 的对象字面量表示法，那是 JavaScript 最精华的部分之一。尽管只是 JavaScript 的一个子集，但它与语言无关。所有以现代编程语言编写的程序，都可以用它来彼此交换数据。它是一种文本格式，所以可以被人和机器阅读。它易于实现且易于使用。大量关于 JSON 的资料都可以在  中找到。 JSON 语法JSON 有 6 种类型的值：对象，数组，字符串，数字，布尔值和特殊值 null。空白（空格符，制表符，回车符和换行符）可被插到任何值的前后。这使得 JSON 文本能更容易被人阅读。为了减少传输和存储的成本，空白可以省略。 JSON 对象是一个容纳 “名/值” 对的无序集合。名字可以是任何字符串。值可以是任何类型的 JSON 值，包括数组和对象。JSON 对象可以被无限层地嵌套，但一般来说保持其结构的相对扁平是最高效的。大多数语言都有容易映射为 JSON 对象的数据类型，比如对象（object),结构（struct)，字典（dictionary），哈希表（hash table），属性列表（property list）或关联数组（associative array）。 JSON 数组是一个值的有序序列。其值可以是任何类型的 JSON 值，包括数组和对象。大多数语言都有容易被映射为 JSON 数组的数据类型，比如数组（array），向量（vector），列表（list）或序列（sequence）。 JSON 字符串被包围在一对双引号之间。\\字符被用于转义。JSON 允许/字符被转义，所以 JSON 可以嵌入 HTML 的&lt;script&gt;标签之中。 JSON 数字与 JavaScript 的数字相似。整数的首位不允许为 0 ，因为一些语言用它来表示八进制数。这种基数混乱在数据交换格式中是不可取的。数字可以是整数，实数或科学计数。 就是这样。这就是 JSON 的全部。JSON 的设计目标是成为一个极简的，轻便的和文本式的 JavaScript 子集。实现互通所需要的共识越少，互通就越容易实现。 安全地使用 JSONJSON 特别易于用在 Web 应用中，因为 JSON 就是 JavaScript。使用 eval 函数可以把一段 JSON 文本转化成一个有用的数据结构： (用圆括号把 JSON 文本括起来是一种避免 JavaScript 语法歧义的变通方案) 然而，eval 函数有着骇人的安全问题。用eval 去解析 JSON 文本安全吗？… 通过使用 JSON.parse 方法代替 eval 就能避免这种危险。如果文本中包含任何危险数据，那么 JSON.parse 将抛出一个异常… 在外部数据与 innerHTML 进行交互时还存在一个危险… 一个 JSON 解析器这是一个用 JavaScript 编写 JSON 解析器的实现方案： 《JavaScript 语言精粹》（修订版）Douglas Crockford著 电子工业出版社 "},{"title":"算法优化之记忆","date":"2021-04-24T16:19:00.000Z","url":"/blog/2021/04/25/memoization/","tags":["algorithm","optimization","memoization"],"categories":["Others"],"content":" 在计算机领域，记忆（memoization）是主要用于加速程序计算的一种优化技术，它使得函数避免重复演算之前已被处理的输入，而返回已缓存的结果。 记忆 Memoization函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。这种优化被称为记忆（memoization）。JavaScript 的对象和数组要实现这种优化是非常方便的。 比如说，我们想要一个递归函数来计算 Fibonacci 数列。一个 Fibonacci 数字是之前两个 Fibonacci 数字之和。最前面的两个数字是 0 和 1。 这样是可以工作的，但它做了很多无谓的工作。fib 函数被调用了 453 次。我们调用了 11 次，而它自身调用了 442 次去计算可能已被刚计算过的值。如果我们让该函数具备记忆功能，就可以显著地减少运算量。 我们在一个名为 memo 的数组里保存我们的存储结果，存储结果可以隐藏在闭包中。当函数被调用时，这个函数首先检查结果是否已存在，如果已经存在，就立即返回这个结果。 这个函数返回同样的结果，但它只被调用了 29 次。我们调用了它 11 次，它调用了自己 181 次去取得之前存储的结果。 我们可以吧这种技术推而广之，编写一个函数帮助我们构造带记忆功能的函数。 memoizer 函数取得一个初始的 memo 数组和 formula 函数。它返回一个管理 memo 存储和在需要时调用 formula 函数的 recur 函数。我们把这个 recur 函数和它的参数传递给 formula 函数： 现在，我们可以使用 memoizer 函数来定义 fibonacci 函数，提供其初始的 memo 数组和 formula 函数： 通过设计这种产生另一个函数的函数，极大地减少了我们的工作量。例如，要产生一个可记忆的阶乘函数，我们只需要通过基本的阶乘公式即可： 《JavaScript 语言精粹》（修订版）Douglas Crockford著 电子工业出版社 "}]